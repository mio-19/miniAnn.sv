// generated by sv2v
module neuron_learn (
	clock,
	valid,
	learn,
	in,
	out,
	weights,
	activation_upper_bound,
	activation_lower_bound,
	expected_out,
	expected_in
);
	parameter N = 16;
	input wire clock;
	input wire valid;
	input wire learn;
	input wire [(N * 16) - 1:0] in;
	output wire [15:0] out;
	output reg [(N * 17) - 1:0] weights;
	output reg [16:0] activation_upper_bound;
	output reg [16:0] activation_lower_bound;
	input wire [15:0] expected_out;
	output reg [(N * 16) - 1:0] expected_in;
	wire [16:0] average;
	wire average_too_big;
	wire average_too_small;
	wire [15:0] activation_space;
	neuron_run #(.N(N)) neuron_run_instance(
		.in(in),
		.out(out),
		.weights(weights),
		.activation_upper_bound(activation_upper_bound),
		.activation_lower_bound(activation_lower_bound),
		.average(average),
		.average_too_big(average_too_big),
		.average_too_small(average_too_small),
		.activation_space(activation_space)
	);
	function [16:0] unit_signed_from_unit;
		input reg [15:0] i;
		unit_signed_from_unit = {1'b0, i};
	endfunction
	function [16:0] unit_signed_add_aux;
		input reg [17:0] x;
		unit_signed_add_aux = {x[17], (x[17] == 1'b0 ? (x[16] == 1'b0 ? x[15:0] : ~16'b0000000000000000) : (x[16] == 1'b1 ? x[15:0] : 16'b0000000000000000))};
	endfunction
	function [16:0] unit_signed_add_overflow_to_max_min;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_add_overflow_to_max_min = unit_signed_add_aux($signed(x) + $signed(y));
	endfunction
	function [16:0] unit_signed_sub_overflow_to_max_min;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_sub_overflow_to_max_min = unit_signed_add_overflow_to_max_min(x, -y);
	endfunction
	function [16:0] unit_sub_signed;
		input reg [15:0] x;
		input reg [15:0] y;
		unit_sub_signed = unit_signed_sub_overflow_to_max_min(unit_signed_from_unit(x), unit_signed_from_unit(y));
	endfunction
	reg [16:0] out_delta_signed = unit_sub_signed(expected_out, out);
	function unit_signed_postive;
		input reg [16:0] x;
		unit_signed_postive = !x[16];
	endfunction
	reg out_delta_postive = unit_signed_postive(out_delta_signed);
	function unit_signed_negative;
		input reg [16:0] x;
		unit_signed_negative = x[16];
	endfunction
	reg out_delta_negative = unit_signed_negative(out_delta_signed);
	function [15:0] unit_signed_abs_unit;
		input reg [16:0] x;
		unit_signed_abs_unit = (x[16] ? -x[15-:16] : x[15-:16]);
	endfunction
	reg [15:0] out_delta_abs = unit_signed_abs_unit(out_delta_signed);
	function [15:0] unit_mul_aux;
		input reg [32:0] result;
		unit_mul_aux = result[31:16];
	endfunction
	function [15:0] unit_mul;
		input reg [15:0] x;
		input reg [15:0] y;
		unit_mul = unit_mul_aux($unsigned(x) * $unsigned(y));
	endfunction
	function [16:0] unit_signed_opposite;
		input reg [16:0] x;
		unit_signed_opposite = -x;
	endfunction
	function [16:0] unit_signed_mul;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_mul = (x[16] == y[16] ? unit_mul(unit_signed_abs_unit(x), unit_signed_abs_unit(y)) : unit_signed_opposite(unit_mul(unit_signed_abs_unit(x), unit_signed_abs_unit(y))));
	endfunction
	function [16:0] out_delta_signed_mul;
		input reg [16:0] x;
		out_delta_signed_mul = unit_signed_mul(out_delta_signed, x);
	endfunction
	reg [N - 1:0] random_v0;
	reg [16:0] random_v1;
	reg [N - 1:0] random_v2;
	function [15:0] unit_tunit_add_aux;
		input reg [16:0] r;
		unit_tunit_add_aux = (r[16] ? 16'hffff : r[15:0]);
	endfunction
	function [15:0] unit_add;
		input reg [15:0] x;
		input reg [15:0] y;
		unit_add = unit_tunit_add_aux($unsigned(x) + $unsigned(y));
	endfunction
	function unit_signed_lesser;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_lesser = $signed(x) < $signed(y);
	endfunction
	function [15:0] unit_sub_overflow_as_min;
		input reg [15:0] x;
		input reg [15:0] y;
		unit_sub_overflow_as_min = (x > y ? x - y : 16'b0000000000000000);
	endfunction
	always @(posedge clock or negedge valid)
		if (!valid) begin
			begin : sv2v_autoblock_1
				integer i;
				for (i = N - 1; i >= 0; i = i - 1)
					begin
						if (random_v0[i])
							weights[i * 17+:17] <= weights[i * 17+:17] - random_v1;
						if (random_v2[i])
							random_v0[i] <= random_v0[i] ^ ^in[i * 16+:16];
						else if (random_v0[i] ^ random_v2[i])
							random_v0[i] <= random_v0[i] ^ ~^expected_out;
					end
			end
			if (random_v0[0])
				activation_upper_bound <= activation_upper_bound + random_v1;
			if (random_v0[1])
				activation_lower_bound <= activation_lower_bound ^ random_v1;
			random_v1 <= random_v0 - random_v1;
			random_v2 <= (random_v0 + random_v1) - random_v2;
		end
		else if (learn)
			if (unit_signed_lesser(activation_upper_bound, activation_lower_bound))
				{activation_upper_bound, activation_lower_bound} <= {activation_lower_bound, activation_upper_bound};
			else begin
				if (average_too_small && out_delta_postive)
					activation_lower_bound <= unit_signed_sub_overflow_to_max_min(activation_lower_bound, out_delta_signed_mul(unit_signed_sub_overflow_to_max_min(activation_lower_bound, average)));
				if (average_too_big && out_delta_negative)
					activation_upper_bound <= unit_signed_add_overflow_to_max_min(activation_upper_bound, out_delta_signed_mul(unit_signed_sub_overflow_to_max_min(average, activation_upper_bound)));
				begin : sv2v_autoblock_2
					integer i;
					for (i = N - 1; i >= 0; i = i - 1)
						if (unit_signed_postive(weights[i * 17+:17]) == out_delta_postive) begin
							expected_in[i * 16+:16] <= unit_add(in[i * 16+:16], unit_mul(out_delta_abs, unit_mul(unit_signed_abs_unit(weights[i * 17+:17]), activation_space)));
							weights[i * 17+:17] <= unit_signed_add_overflow_to_max_min(weights[i * 17+:17], out_delta_signed_mul(weights[i * 17+:17]));
						end
						else begin
							weights[i * 17+:17] <= unit_signed_sub_overflow_to_max_min(weights[i * 17+:17], out_delta_signed_mul(weights[i * 17+:17]));
							expected_in[i * 16+:16] <= unit_sub_overflow_as_min(in[i * 16+:16], unit_mul(out_delta_abs, unit_mul(unit_signed_abs_unit(weights[i * 17+:17]), activation_space)));
						end
				end
			end
endmodule
