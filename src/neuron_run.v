// generated by sv2v
module neuron_run (
	in,
	out,
	weights,
	activation_upper_bound,
	activation_lower_bound,
	average,
	average_too_big,
	average_too_small,
	activation_space
);
	parameter N = 16;
	input wire [(N * 16) - 1:0] in;
	output reg [15:0] out;
	input wire [(N * 17) - 1:0] weights;
	input wire [16:0] activation_upper_bound;
	input wire [16:0] activation_lower_bound;
	output wire [16:0] average;
	output reg average_too_big;
	output reg average_too_small;
	output wire [15:0] activation_space;
	function [15:0] unit_signed_abs_unit;
		input reg [16:0] x;
		unit_signed_abs_unit = (x[16] ? -x[15-:16] : x[15-:16]);
	endfunction
	function [16:0] unit_signed_add_aux;
		input reg [17:0] x;
		unit_signed_add_aux = {x[17], (x[17] == 1'b0 ? (x[16] == 1'b0 ? x[15:0] : ~16'b0000000000000000) : (x[16] == 1'b1 ? x[15:0] : 16'b0000000000000000))};
	endfunction
	function [16:0] unit_signed_add_overflow_to_max_min;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_add_overflow_to_max_min = unit_signed_add_aux($signed(x) + $signed(y));
	endfunction
	function [16:0] unit_signed_sub_overflow_to_max_min;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_sub_overflow_to_max_min = unit_signed_add_overflow_to_max_min(x, -y);
	endfunction
	assign activation_space = unit_signed_abs_unit(unit_signed_sub_overflow_to_max_min(activation_upper_bound, activation_lower_bound));
	reg [31:0] sum;
	function [31:0] frac_signed_div_int;
		input reg [31:0] x;
		input reg signed [31:0] y;
		frac_signed_div_int = $signed(x) / y;
	endfunction
	function [16:0] frac_to_unit_signed_overflow_to_max_min;
		input reg [31:0] x;
		frac_to_unit_signed_overflow_to_max_min = (x[31:16] == 0 ? {1'b0, x[15:0]} : (~x[31:16] == 0 ? {1'b1, x[15:0]} : (x[31] ? 17'b10000000000000000 : {1'b0, ~16'b0000000000000000})));
	endfunction
	assign average = frac_to_unit_signed_overflow_to_max_min(frac_signed_div_int(sum, N));
	function [31:0] frac_add;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_add = x + y;
	endfunction
	function [64:0] frac_mul_aux;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_mul_aux = $signed(x) * $signed(y);
	endfunction
	function [31:0] frac_mul_aux1;
		input reg [64:0] result;
		frac_mul_aux1 = {result[64], result[46:16]};
	endfunction
	function [31:0] frac_mul;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_mul = frac_mul_aux1(frac_mul_aux(x, y));
	endfunction
	function [31:0] unit_to_frac;
		input reg [15:0] x;
		unit_to_frac = {16'b0000000000000000, x};
	endfunction
	function [31:0] unit_mul_frac;
		input reg [15:0] x;
		input reg [31:0] y;
		unit_mul_frac = frac_mul(unit_to_frac(x), y);
	endfunction
	function [31:0] unit_signed_to_frac;
		input reg [16:0] x;
		unit_signed_to_frac = $signed(x);
	endfunction
	always @(*) begin
		sum = 32'b00000000000000000000000000000000;
		begin : sv2v_autoblock_1
			integer i;
			for (i = N - 1; i >= 0; i = i - 1)
				sum = frac_add(sum, unit_mul_frac(in[i * 16+:16], unit_signed_to_frac(weights[i * 17+:17])));
		end
	end
	function unit_signed_bigger;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_bigger = $signed(x) > $signed(y);
	endfunction
	function unit_signed_lesser;
		input reg [16:0] x;
		input reg [16:0] y;
		unit_signed_lesser = $signed(x) < $signed(y);
	endfunction
	function frac_negative;
		input reg [31:0] x;
		frac_negative = x[31];
	endfunction
	function [31:0] frac_opposite;
		input reg [31:0] x;
		frac_opposite = -x;
	endfunction
	function [31:0] frac_abs;
		input reg [31:0] x;
		frac_abs = (frac_negative(x) ? frac_opposite(x) : x);
	endfunction
	function [31:0] frac_unsigned_div_helper_aux;
		input reg [63:0] x;
		frac_unsigned_div_helper_aux = {1'b0, x[30:0]};
	endfunction
	function [31:0] frac_unsigned_div_helper;
		input reg [63:0] x;
		input reg [63:0] y;
		frac_unsigned_div_helper = frac_unsigned_div_helper_aux($unsigned(x) / $unsigned(y));
	endfunction
	function [31:0] frac_unsigned_div;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_unsigned_div = frac_unsigned_div_helper({x, 16'b0000000000000000, 16'b0000000000000000}, {32'b00000000000000000000000000000000, y});
	endfunction
	function [31:0] frac_abs_div;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_abs_div = frac_unsigned_div(frac_abs(x), frac_abs(y));
	endfunction
	function [31:0] frac_div;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_div = (frac_negative(x) == frac_negative(y) ? frac_abs_div(x, y) : frac_opposite(frac_abs_div(x, y)));
	endfunction
	function [31:0] frac_sub;
		input reg [31:0] x;
		input reg [31:0] y;
		frac_sub = x - y;
	endfunction
	function [15:0] unit_signed_scale;
		input reg [16:0] x;
		input reg [16:0] base;
		input reg [15:0] space;
		unit_signed_scale = frac_to_unit_signed_overflow_to_max_min(frac_div(frac_sub(unit_signed_to_frac(x), unit_signed_to_frac(base)), unit_to_frac(space)));
	endfunction
	always @(*)
		if (unit_signed_lesser(average, activation_lower_bound)) begin
			out = 16'b0000000000000000;
			average_too_big = 1'b0;
			average_too_small = 1'b1;
		end
		else if (unit_signed_bigger(average, activation_upper_bound)) begin
			out = 16'hffff;
			average_too_big = 1'b1;
			average_too_small = 1'b0;
		end
		else begin
			out = unit_signed_scale(average, activation_lower_bound, activation_space);
			average_too_big = 1'b0;
			average_too_small = 1'b0;
		end
endmodule
